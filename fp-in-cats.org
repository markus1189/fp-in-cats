* Top Secret
#+BEGIN_SRC elisp
(define-minor-mode org-presentation-mode
  "Toggle org presentation mode."
  :init-value nil
  :lighter: " P"
  :group 'org-pres)

(defvar org-presentation-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "<prior> <prior>") 'org-presentation-prev)
    (define-key map (kbd "<next> <next>") 'org-presentation-next)
    (define-key map (kbd "<next> <next>") 'org-presentation-next)
    (define-key map (kbd "<prior> .") 'org-previous-block)
    (define-key map (kbd "<next> .") 'org-next-block)
    (define-key map (kbd ". .") 'org-ctrl-c-ctrl-c)
    (define-key map (kbd ". <next>") 'org-shifttab)
    (define-key map (kbd "ESC <f5>") 'keyboard-quit)
    (define-key map (kbd "<f5> ESC") 'keyboard-quit)
    (define-key map (kbd "ESC .") 'org-display-inline-images)
    (define-key map (kbd "<f5> .") 'org-display-inline-images)
    (define-key map (kbd "q") (Λ (org-presentation-mode -1)
                                 (text-scale-set 0)))
    map))

(defun org-presentation-next (arg)
  (interactive "p")
  (progn
    (widen)
    (org-next-visible-heading arg)
    (org-narrow-to-subtree)))

(defun org-presentation-prev (arg)
  (interactive "p")
  (progn
    (widen)
    (org-previous-visible-heading arg)
    (org-narrow-to-subtree)))

(org-babel-remove-result-one-or-many '(4))
(org-cycle '(64))
(setq org-confirm-babel-evaluate nil)
(text-scale-set 5)
(org-display-inline-images)
(blink-cursor-mode -1)
(org-presentation-mode)
#+END_SRC

#+RESULTS:
: t

* This evening at Scala User Group Köln Bonn:
#+BEGIN_SRC sh :results output
figlet -d fonts -f doom -w 70 -c -k "FP with cats"
#+END_SRC

* First off, the bad news


                                [[file:pics/cats-dressed-vintage-photo_small_xed.jpg]]

* Check for some basic understanding

-> Who knows about

 -> free adjoint functors?
 -> star-autonomous categories?
 -> geometric morphisms?

* Functional Programming has nothing to do with this

Good! You don't need them anyway. ¯\_(ツ)_/¯

Plan for today:

- Not about how good FP is (but it is!)
- Spot the pattern 1: combine things
- How cats is organized
- Spot the pattern 2: nested things
- Cats vs. Scalaz
- Some pitfalls
- Conclusion

* What is 'cats'

#+BEGIN_QUOTE
Lightweight, modular, and extensible library for functional programming.
#+END_QUOTE

 -> 0.6.0 currently released, 1.0 is not far (ETA: Q3 2016)
 -> Github: https://github.com/typelevel/cats
 -> Guide: http://typelevel.org/cats/
 -> Scaladoc: http://typelevel.org/cats/api/#package

* TODO Why should you learn about 'cats'?

 -> raise the abstraction level
 -> less repetition and duplicated code, less maintenance, less bugs
 -> many common patterns are already implemented here

* Combining stuff (Monoid)

Can you spot a pattern here?

#+BEGIN_SRC scala
val add = (0 + 1) + 5
val mul = (1 * 2) * 5
val cat = (List() ++ List(1)) ++ List(2,3)
#+END_SRC

* Abstracting with Monoids

#+BEGIN_SRC scala
val add = (empty |+| 1) |+| 5
val mul = (empty |+| 2) |+| 5
val mul = (empty |+| List(1)) |+| List(2,3)
#+END_SRC

The general structure of the computation is the same

* Definition of Monoids

The Monoid type class:

#+BEGIN_SRC scala
trait Monoid[A] {
  def empty: A

  def combine(x: A, y: A): A
}
#+END_SRC

* Monoid Rules

Implementations have to obey some rules:

#+BEGIN_EXAMPLE

1) empty |+| x === x

2) x |+| empty === x

3) (x |+| y) |+| z === x |+| (y |+| z)

#+END_EXAMPLE

* Let's define some Monoids

1) Addition
2) Multiplication
3) List concatenation

#+BEGIN_SRC scala
object Monoid {
  type X = ???
  val ourMonoid: Monoid[X] = new Monoid[X] {
    override def empty: X = ???
    override def combine(x: X, y: X): X = ???
  }
}
#+END_SRC
* Monoids can be combined

We can build monoids from monoids:

#+BEGIN_SRC scala
def option[A:Monoid] = new Monoid[Option[A]] {
  def empty = None

  def combine(x: Option[A], y: Option[A]) = (x,y) match {
    case (Some(xx),Some(yy)) => Some(xx |+| yy)
    case (Some(xx),None) => Some(xx)
    case (None,Some(yy)) => Some(yy)
    case (None,None) => None
  }
}
#+END_SRC

* Monoids everywhere

#+BEGIN_SRC scala
1 |+| 2                           // 3
Future(1) |+| Future(2)           // Future(3)
Some("Hello, ") |+| Some("World") // Some("Hello, World")
#+END_SRC

Also:

  - Order[A] (lexical ordering)
  - Either[A,B] if Monoid[B]
  - A => B      if Monoid[B]
  - Map[A,B]    if Monoid[B]
  - (A,B) if Monoid[A] and Monoid[B]

* Monoids for the real world

         [[file:pics/skeptical.jpg]]

* Apache Spark

Task: calculate statistics with Apache Spark

  a) number of words
  b) word count per word
  c) average word length
  +) make it easy to extend

Easy? Only do *one* traversal over the input

* But before, let's talk about cats

    [[file:pics/cat_appears.jpg]]

* Cats, a library for FP in Scala

-> cats defines a lot of things
-> organization is confusing at first
  -> but obvious after learning some rules

=> let's take a look

* General structure of packages in cats

| package       | contains                     | examples          |
|---------------+------------------------------+-------------------|
| ~cats~        | type classes                 | Functor,Monoid    |
| ~cats.kernel~ | essential type classes       | Eq, Ordering      |
| ~cats.std~    | instances for standard Scala | List,Vector,Tuple |
| ~cats.data~   | data types                   | Xor,Validated     |
| ~cats.syntax~ | /optional/ syntactic sugar   |                   |

* Imports: à la carte or the whole menu
#+BEGIN_SRC dot :file packages.png :cmdline -Tpng -Nfontsize=18
digraph {
rankdir=LR;
catsImplicits [label="cats.implicits"];

catsStdAll [label="cats.std.all"];
{ rank=same;
  catsStdFuture [label="cats.std.future"];
  catsStdOption [label="cats.std.option"];
  catsStdElse [label="cats.std.<...>"];
}

catsSyntaxAll [label="cats.syntax.all"];
{ rank=same;
  catsSyntaxTraverse [label="cats.syntax.traverse"];
  catsSyntaxSemigroup [label="cats.syntax.semigroup"];
  catsSyntaxElse [label="cats.syntax.<...>"];
}

catsImplicits -> catsStdAll;
catsImplicits -> catsSyntaxAll;

catsStdAll -> catsStdFuture;
catsStdAll -> catsStdOption;
catsStdAll -> catsStdElse;

catsSyntaxAll -> catsSyntaxTraverse;
catsSyntaxAll -> catsSyntaxSemigroup;
catsSyntaxAll -> catsSyntaxElse;
}
#+END_SRC

#+RESULTS:
[[file:packages.png]]

1) Import /everything/: ~import cats.implicits._~
2) Import /packages/:   ~import cats.<...>.all._~
3) Import /à la carte/: ~import cats.std.future._~

* It's up to you

#+BEGIN_SRC scala
import cats.implicits._

(List(1),List("a")) |+| (List(2),List("b"))
#+END_SRC

 VS

#+BEGIN_SRC scala
import cats.syntax.semigroup._
import cats.std.tuple._
import cats.std.list._

(List(1),List("a")) |+| (List(2),List("b"))
#+END_SRC
* Having fine grained imports

  [[file:pics/modular.jpeg]]

* Where to find it

 ?) typeclass (Monoid,Ordering)
   -> ~cats~,
      or ~cats.kernel~ (since 0.6.0+)

 ?) data type (Xor, Validated)
   -> ~cats.data~

 ?) instances (List monoid, ordering for xyz)
   -> ~cats.std.<...>~,
      or ~cats.kernel.<...>~

* Middle ground for imports with package objects

package object
  + some explicit imports
  + chained package clauses

#+BEGIN_SRC scala
package object codecentric extends CatsPkg

trait CatsPkg
  extends FutureInstances
  with ListInstances
  with SemigroupSyntax
  // with ...
#+END_SRC

* Using apply vs syntax

-> use typeclass explicitly
-> or import the provided syntax magic

#+BEGIN_SRC scala
Functor[Option].void(Option("42"))

Option("42").void
#+END_SRC

-> mostly up to you but pitfalls apply (later)

* Apache Spark - Using Monoids

#+BEGIN_SRC scala
// Monoid for Map, Option & Integer addition

def step(word: String) = (1,Map(word->1),word.length)

val data = sc.textFile(file).flatMap(_.split("""\s+""")).map(step)

val z = Monoid.empty[(Int,Map[String,Int],Int)]

val (words,wordCount,chars) = data.fold(z)(_ |+| _)
#+END_SRC

** Apache Spark - Extension: Max word length
#+BEGIN_SRC scala
// define Monoid instance for Max

def step(word: String) =
  (1,Map(word->1),word.length,Option(Max(word.length)))

val data = sc.textFile(file).flatMap(_.split("""\s+""")).map(step)

val z = Monoid.empty[(Int,Map[String,Int],Int,Option[Max[Int]])]

val (words,wordCount,chars,max) = data.fold(z)(_ |+| _)
#+END_SRC

* From Apache Spark back to cats

    [[file:pics/cat_appears2.jpg]]

* Spot the pattern (round 2)

#+BEGIN_SRC scala
TODO
#+END_SRC

* TODO cats vs scalaz
- cats: most stuff you'll need, but still some things missing
- cats: more modular: cats-core, cats-free, dogs, kittens
- cats: circe for JSON
- scalaz: no Task and Scalaz-Stream (soon: fs2)
- scalaz: monocle (lenses)
- scalaz: tagged, for alternative instances

* Pitfalls

-> there are some subtle issues when starting with cats
-> we are going to look at some pitfalls
-> some are IntelliJ related, other specific to compiler

* Cats can't find the instance

#+BEGIN_SRC scala
import cats.std.future._
import cats.syntax.functor._
import scala.concurrent._

Functor[Future].map(Future.successful("42"))(_.toInt)
#+END_SRC



* The end
#+BEGIN_SRC sh :results output
figlet -d fonts -f doom -w 70 -c -k "The End"
#+END_SRC

* Bonus
#+BEGIN_SRC sh :results output
figlet -d fonts -f doom -c -k -w 70 "No, really. The End"
#+END_SRC

#+RESULTS:
#+begin_example
          _   _                              _  _
         | \ | |                            | || |
         |  \| |  ___      _ __  ___   __ _ | || | _   _
         | . ` | / _ \    | '__|/ _ \ / _` || || || | | |
         | |\  || (_) |_  | |  |  __/| (_| || || || |_| | _
         \_| \_/ \___/( ) |_|   \___| \__,_||_||_| \__, |(_)
                      |/                            __/ |
                                                   |___/
               _____  _             _____            _
              |_   _|| |           |  ___|          | |
                | |  | |__    ___  | |__  _ __    __| |
                | |  | '_ \  / _ \ |  __|| '_ \  / _` |
                | |  | | | ||  __/ | |___| | | || (_| |
                \_/  |_| |_| \___| \____/|_| |_| \__,_|


#+end_example

* Typesafe equality
** The sad story of '=='
#+BEGIN_SRC scala
type Email = String // TODO: make value class

def isInternal(email: Email): Boolean = {
  "admin@mail.com" == email ||
    "developer@mail.com" == email
}

isInternal("customer@mail.com") // => false
isInternal("admin@mail.com")    // => true
#+END_SRC

** Refactoring time
#+BEGIN_SRC scala
case class Email(value: String) // extends AnyVal

def isInternal(email: Email): Boolean = {
  "admin@mail.com" == email ||
    "developer@mail.com" == email
}

isInternal(Email("customer@mail.com"))
isInternal(Email("admin@mail.com"))
#+END_SRC

** An alternative: 'Eq'
#+BEGIN_SRC scala
import cats.kernel.Eq          // the Eq type class
import cats.syntax.eq._ // === syntax

case class Email(value: String) extends AnyVal
object Email {
  val eqEmail: Eq[Email] =
    Eq.fromUniversalEquals
}

def isInternal(email: Email): Boolean = {
  "admin@mail.com" === email ||
    "developer@mail.com" === email
}
#+END_SRC

** Summary: ~Eq~
- equality based on type classes is safer
- allows you to catch errors during refactoring
-
- will *not* compile
- many ~Eq~ instances predefined
- still some work required for own types

* Xor, the Greek God of Error

#+BEGIN_SRC scala
def validatePassword(pw: String): Boolean = {
  def minLength(s: String): Xor[String,Unit]
}
#+END_SRC

* Local words
#  LocalWords:  adjoint functors monoids morphisms
